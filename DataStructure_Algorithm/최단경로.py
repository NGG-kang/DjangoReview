# 최단 경로 알고리즘
# 가장 짧은 경로를 찾는 알고리즘
#
# 한 지점에서 다른 한 지점까지의 최단 경로
# 한 지점에서 다른 모든 지접까지의 최단 경로
# 모든 지점에서 다른 모든 지점까지의 최단 경로
#
# 각 지점은 그래프에서 노드로 표현
# 지점 간 연결된 도로는 그래프에서 간선으로 표현


# 다익스트라 최단 경로 알고리즘
# 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로 계산
# 다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작
# 현실 세계의 도로는 음의 간선으로 표현되지 않는다
# 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류된다
# 매 상황에서 가장 비용이 적은 노느를 선택해 임의의 과정을 반복한다
#
# 알고리즘 동작 과정
# 1. 출발 노드를 설정
# 2. 최단 거리 테이블을 초기화(자기자신 거리는0, 다음 노드는 무한으로 설정)
# 3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
# 4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
# 5. 위 과정에서 3번과 4번을 반복

# 다익스트라 알고리즘 특징
# 그리디 알고리즘 : 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정을 반복
# 단계를 거치며 한 번 처리된 노드의 최단 거리는 고정되어 더 이상 바뀌지 않는다
# 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다
# 다익스트라 알고리즘을 수행한 뒤에 테이블에 각 노들까지의 최단 거리 정보가 저장된다
# 완벽한 형태의 최단 경로를 구하려면 소스코드에 추가적인 기능을 더 넣어야 한다

# 다익스트라 알고리즘 간단한 구현 방법
# 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)한다

# 총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 한다
# 따라서 전체 시간 복잡도는 O(V2)이다
# 일반적으로  코딩 테스트의 최단 경로 문제에서 전체 노드의 개수가 5000개 이하라면 문제 해결 가능
# 파이썬은 1초에 2천만번
# 하지만 10000개를 넘어가면?

# 우선순위 큐
# 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
# 예를 들어 여러 개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는경우에 우선순위 큐 이용 가능
# 표준 라이브러리 형태로 지원한다

# 힙
# 우선순위 큐(Priority Queue)를 구현하기 위해 사용하는 자료구조 중 하나
# 최소힙, 최대힙이 있다
# 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 사용된다
# 리스트 삽입시간 O(1) 삭제시간 O(N)
# 힙 삽입시간 O(logN) 삭제시간 O(logN)

# 기본적으로 최소힙(오름차순)으로 지원된다
import heapq
# 주석처럼 -를 주면 최대 힙(내림차순)을 구현할 수 있다
def heapsort(iterable):
    h = []
    result = []
    # 모든 원소를 차례대로 힙에 삽입
    for value in iterable:
        heapq.heappush(h, value) # heapq.heappush(h, -value)
    # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
    for i in range(len(h)):
        result.append(heapq.heappop(h)) # result.append(-heapq.heappop(n))
    return result

result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])


# 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 힙 자료구조를 이용한다
# 다익스트라 알고리즘이 동작하는 기본 원리는 동일하다
# 현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용한다는 점이 다르다
# 현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 사용한다

# 그래프를 준비하고 출발 노드를 설정하여 우선순위 큐에 삽입
# 우선순위 큐에서 원소를 꺼낸다. 1번 노드는 아직 방문하지 앟았으므로 이를 처리
# 1번에 연결된 노드와 거리를 우선순위 큐에 넣는다


# 힙 자료구조를 이용하는 다익스트라자 알고리즘의 시간복잡도는  O(ElogV)
# 노드를 하나씩 꺼내 검사하는 반복문(while)은 노드의 개수 V 이상의 횟수로는 처리되지 않는다
# 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총횟수는 최대 간선의
# 개수(E)만큼 연산이 수행될 수 있다

# 직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사하다
# 시간 복잡도를 O(ElogE) 판단할 수 있다
# 중복 간선을 포함하지 않는 경우에 이를 O(ElogV)로 정리할 수 있다
# O(ElogE) -> O(ElogV2) -> O(2ElogV) -> O(ElogV)


# 플로이드 워셜 알고리즘
# 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산
# 플로이드 워셜 알고리즘은 다익스트라 알고리즘과 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행
# 다만 매 단계마다 방문하지 않은 노드 중에 최단거리를 갖는 노드를 찾는 과정이 필요하지 않는다
# 플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장한다
# 플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다
#
# 각 단계마다 특정한 노드 k를 거쳐 가는 경우를 확인한다
# a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사한다
# 점화식 D_ab = min(D_ab, D_ak + D_kb)
# 여기서 _는 수식 아래로 들어가는 의미

# 노드의 개수가 N개일 때 알고리즘상으로 N번의 단계를 수행
# 각 단계마다 O(N2)의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려
# 따라서 워셜 알고리즘의 총 시간복잡도는 O(N3)
# 노드의 개수가 500개 이하이더라도 3제곱이면 1억이 넘어가므로 시간초과를 늘 생각해야한다


# 10:53
# 60분
# 시간제한 1초
# 도시개수n, 통로개수 m, 보내고자 하는 도시 C
# 도시 x, 연결도시 y, 가중치 z
# n, m, c = map(int, input().split())
# city = [[] for i in range(n+1)]
# for _ in range(m):
#     x, y, z = map(int, input().split())
#     city[x].append((y,z))
#
# INF = int(1e9)
# distance = [INF]*(n+1)
#
# import heapq
# def dijkstra(start):
#     q = []
#     count = 0
#     heapq.heappush(q,(0, start))
#     distance[start] = 0
#     while q:
#         dist, now = heapq.heappop(q)
#         if distance[now] < dist:
#             continue
#
#         for i in city[now]:
#             cost = dist + i[1]
#             if cost<distance[i[0]]:
#                 distance[i[0]] = cost
#                 heapq.heappush(q, (cost, i[0]))
#                 count += 1
#     return count
#
# num = dijkstra(c)
# max = 0
# for i in range(1, n + 1):
#     if distance[i] != INF:
#         if max < distance[i]:
#             max = distance[i]
#
# print(num, max)

# 1번 도시에서 2번까지 보내는데는 4의 비용
# 1번 도시에서 3번까지 보내는데는 2의 비용
# 1번에서 다른 도시까지 보내는데 총 걸리는 시간 = 2+4가 아닌 동시에 보냈을것이므로 최대값을 구하면 된다


# 회사의 개수n 경로의 개수 m
n, m = map(int, input().split())
INF = int(1e9)
array = [[INF]*(n+1) for _ in range(n+1)]
for i in range(n+1):
    for j in range(n+1):
        if i == j:
            array[i][j] = 0

for i in range(m):
    a, b = map(int, input().split())
    array[a][b] = 1
    array[b][a] = 1
    # 양 방향 이므로 양쪽 다 비용 1로 초기화

x, k = map(int, input().split())
# x번회사, k번회사 / 1번회사를 출발해서 k번 회사 방문후 x번 회사로 가는게 목표
# 그중에 가장 빠른것


for k in range(1, n+1):
    for i in range(1, n+1):
        for j in range(1, n+1):
            array[i][j] = min(array[i][j], array[i][k] + array[k][j])

distance = array[1][k] + array[k][x]

if distance >= INF:
    print("-1")
else:
    print(distance)

