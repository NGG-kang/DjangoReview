# 다이나믹 프로그래밍
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시크는 방법
# 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다
# 다이나믹 프로그래밍의 구현은 일반적으로 두가지 방식(탑다운, 보텀업)으로 구성
# 동적 계획법이라고도 부름
# 일반적인 동적(Dynamic)
# 자료구조에서 동적 할당은 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법
# 반면에 다이나믹 프로그래밍에서 다이나믹은 별다른 의미 없이 사용된 단어
# 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있다
#
# 1. 최적 부분 구조(Optiaml Substructure)
# 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다
# 2. 중복되는 부분문제(Overlapping Subproblem)
# 동일한 작은 문제를 반복적으로 해결해야 한다
#
# ex) 피보나치 수열
# 점화식이란 인접한 항들 사이의 관계식
# an = an-1 + an-2
# a1 = 1
# a2 = 1
#
# 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게된다 O(2의n제곱)
# 피보나치는 중복되는 부분 문제가 여러번 호출 된다
# 이러한 중복되는 문제를 저장해야 한다
#
#
# 메모이제이션
# 한번 계산한 결과를 메모리 공간에 메모하는 기법
# 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
# 값을 기록해 놓는다는 점에서 캐싱이라고도함
#
#
# 탑다운(메모이제이션) 방식은 하향식이라고도 하며 보텀업 방식은 상향식이라고도 한다
# 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식
# 결과 저장용 리스트느 DP테이블이라고도 부른다
# 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미
# 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님
# 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다

# 재귀를 사용한 피보나치
def fiboo(x):
    if x == 1 or x == 2:
        return 1
    return fiboo(x-1) + fiboo(x-2)

# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
# 메모지에이션을 이용한 피보나치는 O(N)
def fibo(x):
    # 종료 조건
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]
# print(fibo(99))

# 보텀업 방식
# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현
for i in range(3, n+1):
    d[i] = d[i-1]+d[i-2]

# print(d[n])


# 다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용할 수 있다
# 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황

# 다이나믹 프로그래밍과 분할 정복의 차이점은 부분 문제의 중복
# 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다
# 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다

# 분할정복 예시 퀵정렬
# 한번 기준 원소가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않는다
# 분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않는다


# 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 거싱 중요
# 가장 먼저 그리디, 구현, 완전 탑색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있다
# 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려해보자
# 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서
# 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있따
# 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많다...



# 11:04, 30분

# n = map(int, input())
# foods = list(map(int, input().split()))
# d = [0] * 100
# d[0] = foods[0]
# d[1] = max(foods[0],foods[1])
# for i in range(2, n):
#     d[i] = max(d[i-1],d[i-2]+foods[i])
# print(d[n-1])


# 11:45, 20분
x = int(input())
count = 0
d = [0] * 30001

for i in range(2, x+1):
    # 현재의 수에서 1을 뺴는 경우
    d[i] = d[i-1]+1
    # 현재의 수가 2로 나누어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)


# 13:35 30분 / 2시 5분까지
n, m = map(int, input().split())
price = []
for i in range(n):
    price.append(map(int, input()))

d = [10001] * (m + 1)

d[0] = 0
for i in range(m):
    for j in range(price[i], m+1):
        if d[j - price[i]] != 10001:
            d[j] = min(d[j], d[j-price[i]]+1)

# if d[m] == 10001:
#     print(-1)
# else:
#     print(d[m])


T = int(input())


# 처음 선택 가능한거 array[0], array[m-1], array[2m-1]....array[m*n-1] n만큼 반복
move = [1, 1-m, 1+m]
# 오른쪽 + 1
# 오른쪽 위 + 1 - m
# 오른쪽 아래 + 1 + m


for tc in range(int(input())):
    n, m = map(int, input().split())
    array = list(map(int, input().split()))

    dp = []
    index = 0
    # m별로 인덱싱해서 2차원 배열 생성
    for i in range(n):
        dp.append(array[index:index+m])
        index += m
        
    for j in range(1, m):
        for i in range(n):
            # 왼쪽 위에서 오는 경우
            # i==0, i==n-1을 체크하여 각 배열의 끝인지를 확인
            if i == 0: left_up = 0
            else: left_up = dp[i-1][j-1]
            # 왼쪽 아래에서 오는 경우
            if i == n-1: left_down = 0
            else: left_down = dp[i+1][j-1]
            # 왼쪽에서 오는 경우
            left = dp[i][j-1]
            dp[i][j] = dp[i][j] + max(left_up, left_down, left)
    result = 0
    for i in range(n):
        result = max(result, dp[i][m-1])
    print(result)




# (LIS)
# Longest Increasing Subsequence
# 점화식 : 이웃하는 두개의 항 사이에 성립하는 관계를 나타내는 관계식
# LIS의 점화식은 아래와 같다
# 모든 0 <= j < i 에 대하여 D[i] = max(D[i], D[j] + 1) if array[j] < array[i]

n = int(input())
soldier = list(map(int, input()))
# 순서를 뒤집어 최장 증가 부분수열 LIS 문제로 변환
soldier.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
dp = [1]*n

# 가장 긴 증가하는 부분 수열 알고리즘 수행
# 모든 앞의 숫자와 비교해서 뒤의 숫자가 앞의 숫자보다 크다면
# 뒤의 숫자 + 1 하여 저장
# 모든 뒤의 숫자를 확인하여 최종적으로 큰 숫자의 + 1임을 확인한다
for i in range(1, n):
    for j in range(0, i):
        if soldier[j] < soldier[i]:
            dp[i] = max(dp[i], dp[i] + 1)

print(n - max(dp))
