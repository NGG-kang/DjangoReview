# 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미
# 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다
# 그리디 해법은 정당성 분석이 중요
# 단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
# 부분적인 최적해가 전체적인 최적해
# 그러니까 가장 최고의 선택 하는걸 했을때 과연 이게 답인지를 생각 하고, 맞다면 그리디를 사용하라는 것


# 어떠한 수 n이 1이 될 때까지 다음의 두 과정중 하나를 반복적으로 수행
# 단 두번째 연산은 n이 k로 나누어 떨어질 때만 선택할 수 있습니다
# 1. n에서 1을 뻅니다
# 2. n을 k로 나눕니다
# n=18, k=4 라면 1, 2 실행한 횟수 3
# n과 k가 주어질 때 n이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성
# 풀이 시간 15분
# 시간제한 2초
# 입력조건
# 첫째 줄에 n(1<=n<=100000)과 K(2<=K<=10000)가 공백을 기준으로 하여 각각 자연수로 주어진다
# 출력조건
# 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력합니다
# 입력예시
# 25 5
# 출력예시
# 2

# n, k = input().split()
# count = 0
# while n!=1:
#     if n%k==0:
#         n /= k
#         count += 1
#     else:
#         n -= 1
#         count += 1
#
# print(int(n))
#
#
# n, k = map(int, input().split())
# result = 0
#
# while True:
#     # n이 k로 나누어 떨어지는 수를 찾기
#     target = (n // k) * k
#     # 나누어 떨어지는 수만큼 빼기(1씩 빼는걸 여러번 반복했다고 result에 저장)
#     result += (n - target)
#     # n이 k보다 작을 때(더 이상 나눌 수 없을 때) 반복문 탈출
#     n = target
#     if n<k:
#         break
#     # k로 나누고, 횟수 1번 추가
#     result += 1
#     n //= k
#
# # 마지막으로 남은 수에 대하여 1씩 빼기?
# result += (n-1)
# print(result)


# 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을때
# 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 * 또는 + 연산자를 넣어
# 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성
# 모든 연산은 왼쪽부터 순서대로(+, * 구분없음)
# 풀이시간 30분
# 시간체한 1초
# 입력조건
# 첫째 줄에 여러개의 숫자로 구성된 하나의 문자열 S가 주어집니다 (1<= S의길이 <= 20)
# 출력조건
# 첫째 줄에 만들어질 수 있는 가장 큰 수를 출력합니다
# 입력예시 1,2
# 02984, 576
# 출력예시 1,2
# 567,   210
# data = input()
#
# result = int(data[0])
#
# for i in range(1, len(data)):
#     num = int(data[i])
#     if num<=1 or result<=1:
#         result += num
#     else:
#         result *= num
# print(result)



한 마을에 모험가가 N명 있습니다
공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있다

# n = input()
# data = list(map(int, input().split()))
# data.sort()
#
# result = 0
# count = 0
# for i in data:
#     count += 1
#     if count >= i:
#         result += 1
#         count = 0
# print(result)


# 구현
# 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
# 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭함
# 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
# 실수 연산을 다루고, 특정 소수점 자리까지 출력해야하는 문제
# 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
# 적절한 라이브러리를 찾아서 사용해야 하는 문제


# 여행가 A는 N*N 크기의 정사각형 공간 위에 서 있습니다. 이 공간은 1 * 1 크기의 정사각형으로 나누어져 있습니다
# 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 죄표는(N,N)에 해당합니다.
# 여행가 A는 상,하,좌,우, 방향으로 이동할 수 있으며, 시작 좌표는 항상(1,1) 입니다
# 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있습니다.
# 계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L,R,U,D 중 하나의 문자가 반복적으로 적혀 있습니다
# 각 문자의 의미는 다음과 같습니다
# L: 왼쪽으로 한 칸 이동
# R: 오른쪽으로 한 칸 이동
# U: 위로 한 칸 이동
# D: 아래로 한 칸 이동
# 이때 여행가 A가 N*N크기의 정사각형 공간을 벗어나는 움직임은 무시됩니다.
# 예를들어 (1,1) 위치에서 L혹은 U를 만나면 무시
# 입력조건
# 첫째줄에 공간의 크기를 나타내는 N이 주어집니다 (1<=N<=100)
# 둘째줄에 여행가 A가 이동할 계획서 내용이 주어집니다 (1<=이동횟수<=100)
# 출력조건
# 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X,Y)를 공백을 기준으로 구분하여 출력합니다

# 입력예시
# 5
# R R R U D D
# 출력 예시
# 3 4

# # 내가 푼 것
# n = int(input())
# plan = list(input().split())
# start = [1,1]
# for i in plan:
#     if i=="U":
#         if start[0]-1==0:
#             continue
#         else:
#             start[0]-=1
#     if i=="D":
#         if start[0]+1==n:
#             continue
#         else:
#             start[0]+=1
#     if i=="R":
#         if start[1] + 1 == n:
#             continue
#         else:
#             start[1] += 1
#     if i=="L":
#         if start[1] - 1 == 0:
#             continue
#         else:
#             start[1] -= 1
#
# print(*start)
#
# # 동영상
# n = int(input())
# x, y = 1,1
# plans = input().split()
#
# dx = [0,0,-1,1]
# dy = [-1,-1,0,0]
# move_types=['L','R','U','D']
#
# for plan in plans:
#     for i in range(len(move_types)):
#         if plan == move_types[i]:
#             nx = x + dx[i]
#             ny = y + dy[i]
#     if nx<1 or ny<1 or nx>n or ny>n:
#         continue
#     x, y = nx, ny
# print(x, y)
#
# # 확실히 동영상 속의 코드가 간결하고 짧은 코드이다
# # 나는 포문 한개만 돈다는 장점이 있긴 하다만... 별 차이는 없을듯




# 정수 n이 입력되면 00시 00분 00초부터 n시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는
# 모든 경우의 수를 구하는 프로그램을 작성하세요
# 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각입니다
# 00시 00분 03초
# 00시 13분 30초
# 입력조건
# 첫째 출에 정수 N이 입력됩니다(0<=N<=23)
# 00시 00분 00초부터 N시 59분 59초까지의 모든 시작 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력합니다
# 입력 예시
# 5
# 출력 에시
# 11475

# n = int(input())
# hour = [0,0]
# sec = [0,0]
# count = 0
#
# list = [3,13,23,33,43,53]
# 3
# for i in range(n+1):
#     for j in range(60):
#         for k in range(60):
#             if '3' in str(i) + str(j) + str(k):
#                 count+=1
#             # if i in list:
#             #     count+=1
#             # else:
#             #     if j in list:
#             #         count+=1
#             #     else:
#             #         if k in list:
#             #             count+=1
# print(count)



# 행복 왕국의 왕실 정원은 체스판과 같은 8*8 좌표 평면입니다.
# 왕실 정원의 특정한 한 칸에 나이트가 서 있습니다
# 나이트는 L자 형태로만 이동할 수 있으며 정원 밖으로 나갈 수 없습니다
# 수평 두칸으로 이동한 뒤에 수직으로 한 칸 이동
# 수직으로 두칸 이동한 뒤에 수평으로 한 칸 이동
# 입력 예시
# c2       a1
# 출력 예시
# 6        2
# 풀이 20분, 제한 1초, 메모리 128MB

# knight = input()
# row = int(knight[1])
# column = int(ord(knight[0])) - int(ord('a')) + 1
# moves = [(-2,-1), (-2,1), (2,-1), (2,1), (-1,-2), (-1,2), (1,-2), (1,2)]
# result = 0
# for move in moves:
#     next_row = row + move[0]
#     next_column = column + move[1]
#
#     if next_row>=1 and next_row<=8 and next_column>=1 and next_column<=8:
#         result +=1
# print(result)



# 알파벳 대문자와 숫자(0~9)로만 구성된 문자열이 입력으로 주어집니다.
# 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력합니다.
# 예를 들어 K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력합니다
# 첫째 줄에 하나의 문자열 S가 주어집니다 (1<= S의 길이 <= 10000)
# 첫쨰 줄에 문제에서 요구하는 정답을 출력합니다
string = input()
num = 0
char = ""
for i in string:
    try:
        num+=int(i)
    except:
        char+=i
if num==0:
    num=""

print(''.join((sorted(list(char))))+str(num))
